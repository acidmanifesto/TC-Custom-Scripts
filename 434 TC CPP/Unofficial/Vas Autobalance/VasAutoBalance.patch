Author: acidmanifesto <joshua.lee.betts@gmail.com>  2021-03-30 11:47:31
Committer: acidmanifesto <joshua.lee.betts@gmail.com>  2021-03-30 11:47:31
Parent: 9d998bd31fc60f9edab5b9b6493245713f2dab9b (Merge remote-tracking branch 'upstream/master')
Branches: master, remotes/origin/master
Follows: TDB434.20091
Precedes: 

    Cata Vas Module
    
    Vas Scales enemies to the Player.
    .vas in game chat command is done by GM level Rank.  with arguments of setoffset, getoffset, checkmap, mapstat, crstat which is all done in game by gm for live changes on the fly.
    Conf included.

------------------------ src/common/Utilities/DataMap.h ------------------------
new file mode 100644
index 0000000000..96ede6ea79
@@ -0,0 +1,75 @@
+/*
+ * Originally written by Rochet2 - Copyright (C) 2018+ AzerothCore <www.azerothcore.org>, released under GNU AGPL v3 license: http://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-AGPL3
+ * Touched up and refactored by SPP MDic for 434 CPP Gwenpool's branch
+ */
+
+#ifndef _DATA_MAP_H_
+#define _DATA_MAP_H_
+
+#include <string>
+#include <unordered_map>
+#include <memory>
+#include <type_traits>
+
+class DataMap
+{
+public:
+    /**
+     * Base class that you should inherit in your script.
+     * Inheriting classes can be stored to DataMap
+     */
+    class Base
+    {
+    public:
+        virtual ~Base() = default;
+    };
+
+    /**
+     * Returns a pointer to object of requested type stored with given key or nullptr
+     */
+    template<class T> T* Get(std::string const& k) const
+    {
+        static_assert(std::is_base_of<Base, T>::value, "T must derive from Base");
+        if (Container.empty())
+            return nullptr;
+
+        auto it = Container.find(k);
+        if (it != Container.end())
+            return dynamic_cast<T*>(it->second.get());
+        return nullptr;
+
+    }
+
+    /**
+     * Returns a pointer to object of requested type stored with given key
+     * or default constructs one and returns that one
+     */
+
+    template<class T, typename std::enable_if<std::is_default_constructible<T>::value, int>::type = 0>
+    T* GetDefault(std::string const& k)
+    {
+        static_assert(std::is_base_of<Base, T>::value, "T must derive from Base");
+        if (T* v = Get<T>(k))
+            return v;
+        T* v = new T();
+        Container.emplace(k, std::unique_ptr<T>(v));
+        return v;
+
+    }
+
+    /**
+     * Stores a new object that inherits the Base class with the given key
+     */
+    void Set(std::string const& k, Base* v) { Container[k] = std::unique_ptr<Base>(v); }
+
+    /**
+     * Removes objects with given key and returns true if one was removed, false otherwise
+     */
+
+    bool Erase(std::string const& k) { return Container.erase(k) != 0; }
+
+private:
+    std::unordered_map<std::string, std::unique_ptr<Base>> Container;
+};
+
+#endif

---------------- src/server/game/Entities/Creature/Creature.cpp ----------------
index 957a1053b6..46b0135877 100644
@@ -864,6 +864,7 @@ void Creature::Update(uint32 diff)
         default:
             break;
     }
+    sScriptMgr->OnCreatureUpdate(this, diff);
 }
 
 void Creature::RegenerateHealth()
@@ -1476,6 +1477,7 @@ void Creature::UpdateLevelDependantStats()
 
     float armor = (float)stats->GenerateArmor(cInfo); /// @todo Why is this treated as uint32 when it's a float?
     SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, armor);
+    sScriptMgr->Creature_SelectLevel(cInfo, this);
 }
 
 float Creature::_GetHealthMod(int32 Rank)

------------------- src/server/game/Entities/Object/Object.h -------------------
index 251342d5d3..19e751a8b6 100644
@@ -19,6 +19,7 @@
 #define _OBJECT_H
 
 #include "Common.h"
+#include "DataMap.h"
 #include "Duration.h"
 #include "GridReference.h"
 #include "GridRefManager.h"
@@ -183,6 +184,8 @@ class TC_GAME_API Object
         AreaTrigger* ToAreaTrigger() { if (GetTypeId() == TYPEID_AREATRIGGER) return reinterpret_cast<AreaTrigger*>(this); else return nullptr; }
         AreaTrigger const* ToAreaTrigger() const { if (GetTypeId() == TYPEID_AREATRIGGER) return reinterpret_cast<AreaTrigger const*>(this); else return nullptr; }
 
+        DataMap CustomData;
+
     protected:
         Object();
 

-------------------- src/server/game/Entities/Unit/Unit.cpp --------------------
index 131ded7cf8..fa5ee98db5 100644
@@ -6484,8 +6484,10 @@ void Unit::SendHealSpellLog(HealInfo& healInfo, bool critical /*= false*/)
 int32 Unit::HealBySpell(HealInfo& healInfo, bool critical /*= false*/)
 {
     // calculate heal absorb and reduce healing
+    Unit* victim = healInfo.GetTarget();
+    uint32 addhealth = healInfo.GetHeal();
     CalcHealAbsorb(healInfo);
-
+    sScriptMgr->ModifyHealRecieved(this, victim, addhealth);
     DealHeal(healInfo);
     SendHealSpellLog(healInfo, critical);
     return healInfo.GetEffectiveHeal();

------------------------- src/server/game/Maps/Map.cpp -------------------------
index bc255741c1..f995254a8b 100644
@@ -18,6 +18,7 @@
 #include "Map.h"
 #include "Battleground.h"
 #include "CellImpl.h"
+#include "Config.h"
 #include "DatabaseEnv.h"
 #include "DisableMgr.h"
 #include "DynamicTree.h"
@@ -4296,7 +4297,9 @@ bool InstanceMap::HasPermBoundPlayers() const
 uint32 InstanceMap::GetMaxPlayers() const
 {
     MapDifficulty const* mapDiff = GetMapDifficulty();
-    if (mapDiff && mapDiff->maxPlayers)
+    if (mapDiff && mapDiff->maxPlayers && (sConfigMgr->GetBoolDefault("AutoBalance.enable", true)))
+        return (mapDiff->maxPlayers == 10 ? 30 : mapDiff->maxPlayers);
+    else
         return mapDiff->maxPlayers;
 
     return GetEntry()->MaxPlayers;

-------------------------- src/server/game/Maps/Map.h --------------------------
index 05d3cc0e57..518877c379 100644
@@ -21,6 +21,7 @@
 #include "Define.h"
 
 #include "Cell.h"
+#include "DataMap.h"
 #include "DynamicTree.h"
 #include "GridDefines.h"
 #include "GridRefManager.h"
@@ -678,6 +679,8 @@ class TC_GAME_API Map : public GridRefManager<NGridType>
             _updateObjects.erase(obj);
         }
 
+        DataMap CustomData;
+
     private:
 
         void LoadMapAndVMap(int gx, int gy);

------------------- src/server/game/Scripting/ScriptMgr.cpp -------------------
index 671e626335..4f9a4e18af 100644
@@ -1329,6 +1329,17 @@ void ScriptMgr::OnWorldUpdate(uint32 diff)
     FOREACH_SCRIPT(WorldScript)->OnUpdate(diff);
 }
 
+void ScriptMgr::SetInitialWorldSettings()
+{
+    FOREACH_SCRIPT(WorldScript)->SetInitialWorldSettings();
+}
+
+float ScriptMgr::VAS_Script_Hooks()
+{
+    float VAS_Script_Hook_Version = 1.03f;
+    return VAS_Script_Hook_Version;
+}
+
 void ScriptMgr::OnHonorCalculation(float& honor, uint8 level, float multiplier)
 {
     FOREACH_SCRIPT(FormulaScript)->OnHonorCalculation(honor, level, multiplier);
@@ -1459,8 +1470,12 @@ void ScriptMgr::OnPlayerEnterMap(Map* map, Player* player)
     ASSERT(map);
     ASSERT(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerEnterAll(map, player);
+
     FOREACH_SCRIPT(PlayerScript)->OnMapChanged(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerLeaveAll(map, player);
+
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnPlayerEnter(map, player);
     SCR_MAP_END;
@@ -2108,6 +2123,39 @@ void ScriptMgr::ModifySpellDamageTaken(Unit* target, Unit* attacker, int32& dama
     FOREACH_SCRIPT(UnitScript)->ModifySpellDamageTaken(target, attacker, damage);
 }
 
+void ScriptMgr::ModifyHealRecieved(Unit* target, Unit* attacker, uint32& damage)
+{
+    FOREACH_SCRIPT(UnitScript)->ModifyHealRecieved(target, attacker, damage);
+}
+
+//Called From Unit::DealDamage
+//uint32 ScriptMgr::DealDamage(Unit *AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype) {
+//    FOR_SCRIPTS_RET(UnitScript, itr, end, damage)damage = itr->second->DealDamage(AttackerUnit, pVictim, damage, damagetype);
+//    return damage;
+//}
+
+AllMapScript::AllMapScript(const char* name)
+    : ScriptObject(name)
+{
+    ScriptRegistry<AllMapScript>::Instance()->AddScript(this);
+}
+
+AllCreatureScript::AllCreatureScript(const char* name)
+    : ScriptObject(name)
+{
+    ScriptRegistry<AllCreatureScript>::Instance()->AddScript(this);
+}
+
+void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
+{
+    FOREACH_SCRIPT(AllCreatureScript)->OnAllCreatureUpdate(creature, diff);
+}
+
+void ScriptMgr::Creature_SelectLevel(const CreatureTemplate* cinfo, Creature* creature)
+{
+    FOREACH_SCRIPT(AllCreatureScript)->Creature_SelectLevel(cinfo, creature);
+}
+
 SpellScriptLoader::SpellScriptLoader(char const* name)
     : ScriptObject(name)
 {
@@ -2303,10 +2351,12 @@ template class TC_GAME_API ScriptRegistry<SpellScriptLoader>;
 template class TC_GAME_API ScriptRegistry<ServerScript>;
 template class TC_GAME_API ScriptRegistry<WorldScript>;
 template class TC_GAME_API ScriptRegistry<FormulaScript>;
+template class TC_GAME_API ScriptRegistry<AllMapScript>;
 template class TC_GAME_API ScriptRegistry<WorldMapScript>;
 template class TC_GAME_API ScriptRegistry<InstanceMapScript>;
 template class TC_GAME_API ScriptRegistry<BattlegroundMapScript>;
 template class TC_GAME_API ScriptRegistry<ItemScript>;
+template class TC_GAME_API ScriptRegistry<AllCreatureScript>;
 template class TC_GAME_API ScriptRegistry<CreatureScript>;
 template class TC_GAME_API ScriptRegistry<GameObjectScript>;
 template class TC_GAME_API ScriptRegistry<AreaTriggerScript>;

-------------------- src/server/game/Scripting/ScriptMgr.h --------------------
index dd05b72f6f..3f6fcb6789 100644
@@ -22,6 +22,7 @@
 #include "ObjectGuid.h"
 #include "Tuples.h"
 #include "Types.h"
+#include "Unit.h"
 #include <vector>
 
 class AccountMgr;
@@ -272,6 +273,9 @@ class TC_GAME_API WorldScript : public ScriptObject
 
         // Called when the world is actually shut down.
         virtual void OnShutdown() { }
+
+        // Called at End of SetInitialWorldSettings.
+        virtual void SetInitialWorldSettings() { }
 };
 
 class TC_GAME_API FormulaScript : public ScriptObject
@@ -304,6 +308,21 @@ class TC_GAME_API FormulaScript : public ScriptObject
         virtual void OnGroupRateCalculation(float& /*rate*/, uint32 /*count*/, bool /*isRaid*/) { }
 };
 
+class TC_GAME_API AllMapScript : public ScriptObject
+{
+protected:
+
+    AllMapScript(const char* name);
+
+public:
+
+    // Called when a player enters any Map
+    virtual void OnPlayerEnterAll(Map* /*map*/, Player* /*player*/) { }
+
+    // Called when a player leave any Map
+    virtual void OnPlayerLeaveAll(Map* /*map*/, Player* /*player*/) { }
+};
+
 template<class TMap> class MapScript : public UpdatableScript<TMap>
 {
     MapEntry const* _mapEntry;
@@ -409,6 +428,9 @@ class TC_GAME_API UnitScript : public ScriptObject
 
         // Called when Spell Damage is being Dealt
         virtual void ModifySpellDamageTaken(Unit* /*target*/, Unit* /*attacker*/, int32& /*damage*/) { }
+
+        //Auto Balance VAS
+        virtual void ModifyHealRecieved(Unit* /*target*/, Unit* /*attacker*/, uint32& /*damage*/) { }
 };
 
 class TC_GAME_API CreatureScript : public ScriptObject
@@ -418,10 +440,32 @@ class TC_GAME_API CreatureScript : public ScriptObject
         CreatureScript(char const* name);
 
     public:
+
+        // Called when Heal is Recieved
+        virtual void ModifyHealRecieved(Unit* /*target*/, Unit* /*attacker*/, uint32& /*damage*/) { }
+
+        //VAS AutoBalance
+        // virtual uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype) { return damage;}
+        //
         // Called when a CreatureAI object is needed for the creature.
         virtual CreatureAI* GetAI(Creature* /*creature*/) const = 0;
 };
 
+class TC_GAME_API AllCreatureScript : public ScriptObject
+{
+protected:
+
+    AllCreatureScript(const char* name);
+
+public:
+
+    // Called from End of Creature Update.
+    virtual void OnAllCreatureUpdate(Creature* /*creature*/, uint32 /*diff*/) { }
+
+    // Called from End of Creature SelectLevel.
+    virtual void Creature_SelectLevel(const CreatureTemplate* /*cinfo*/, Creature* /*creature*/) { }
+};
+
 class TC_GAME_API GameObjectScript : public ScriptObject, public UpdatableScript<GameObject>
 {
     protected:
@@ -858,6 +902,11 @@ class TC_GAME_API ScriptMgr
 
         void Unload();
 
+    public: /* {VAS} Script Hooks */
+
+        float VAS_Script_Hooks();
+
+
     public: /* SpellScriptLoader */
 
         void CreateSpellScripts(uint32 spellId, std::vector<SpellScript*>& scriptVector, Spell* invoker) const;
@@ -883,6 +932,7 @@ class TC_GAME_API ScriptMgr
         void OnWorldUpdate(uint32 diff);
         void OnStartup();
         void OnShutdown();
+        void SetInitialWorldSettings();
 
     public: /* FormulaScript */
 
@@ -894,6 +944,10 @@ class TC_GAME_API ScriptMgr
         void OnGainCalculation(uint32& gain, Player* player, Unit* unit);
         void OnGroupRateCalculation(float& rate, uint32 count, bool isRaid);
 
+    public: /* AllScript */
+
+        void OnPlayerEnterMapAll(Map* map, Player* player);
+        void OnPlayerLeaveMapAll(Map* map, Player* player);
     public: /* MapScript */
 
         void OnCreateMap(Map* map);
@@ -916,6 +970,12 @@ class TC_GAME_API ScriptMgr
         bool OnItemRemove(Player* player, Item* item);
         bool OnCastItemCombatSpell(Player* player, Unit* victim, SpellInfo const* spellInfo, Item* item);
 
+    public: /* AllCreatureScript */
+
+        void OnAllCreatureUpdate(Creature* creature, uint32 diff);
+        void Creature_SelectLevel(const CreatureTemplate* cinfo, Creature* creature);
+        void OnCreatureUpdate(Creature* creature, uint32 diff);
+
     public: /* CreatureScript */
 
         CreatureAI* GetCreatureAI(Creature* creature);
@@ -1054,6 +1114,8 @@ class TC_GAME_API ScriptMgr
         void ModifyPeriodicDamageAurasTick(Unit* target, Unit* attacker, uint32& damage);
         void ModifyMeleeDamage(Unit* target, Unit* attacker, uint32& damage);
         void ModifySpellDamageTaken(Unit* target, Unit* attacker, int32& damage);
+        void ModifyHealRecieved(Unit* target, Unit* attacker, uint32& addHealth);
+        // uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype
 
     private:
         uint32 _scriptCount;

----------------------- src/server/game/World/World.cpp -----------------------
index 207490239c..3eccb4344e 100644
@@ -2254,6 +2254,9 @@ void World::SetInitialWorldSettings()
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
+    TC_LOG_INFO("server.loading", "Loading Autobalance...");
+    sScriptMgr->SetInitialWorldSettings();
+
     TC_LOG_INFO("server.loading", "Initialize AuctionHouseBot...");
     sAuctionBot->Initialize();
 

----------------- src/server/scripts/Custom/VasAutobalance.cpp -----------------
new file mode 100644
index 0000000000..8776e86047
@@ -0,0 +1,937 @@
+/*
+* Copyright (C) 2012 CVMagic <http://www.trinitycore.org/f/topic/6551-vas-autobalance/>
+* Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+* Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* Copyright (C) 1985-2010 {VAS} KalCorp  <http://vasserver.dyndns.org/>
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*
+* Script Name: AutoBalance
+* Original Authors: KalCorp and Vaughner
+* Maintainer(s): CVMagic
+* Original Script Name: VAS.AutoBalance
+* Description: This script is intended to scale based on number of players, instance mobs & world bosses' health, mana, and damage.
+*/
+/*
+Touched up by SPP MDic for TC 434 Gwenpool Branch
+*/
+
+#include "Configuration/Config.h"
+#include "Unit.h"
+#include "Chat.h"
+#include "Creature.h"
+#include "LFGMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Map.h"
+#include "ScriptMgr.h"
+#include "Language.h"
+#include <vector>
+#include "Log.h"
+#include "Group.h"
+#include "DataMap.h"
+#include "DBCStores.h"
+
+class AutoBalanceCreatureInfo : public DataMap::Base {
+public:
+    AutoBalanceCreatureInfo() {}
+
+    AutoBalanceCreatureInfo(uint32 count, float dmg, float hpRate, float manaRate, float armorRate, uint8 selLevel) :
+        instancePlayerCount(count), selectedLevel(selLevel), DamageMultiplier(dmg), HealthMultiplier(hpRate), ManaMultiplier(manaRate),
+        ArmorMultiplier(armorRate) {}
+
+    uint32 instancePlayerCount = 0;
+    uint8 selectedLevel = 0;
+    // this is used to detect creatures that update their entry
+    uint32 entry = 0;
+    float DamageMultiplier = 1;
+    float HealthMultiplier = 1;
+    float ManaMultiplier = 1;
+    float ArmorMultiplier = 1;
+
+};
+
+class AutoBalanceMapInfo : public DataMap::Base {
+public:
+    AutoBalanceMapInfo() {}
+
+    AutoBalanceMapInfo(uint32 count, uint8 selLevel) : playerCount(count), mapLevel(selLevel) {}
+
+    uint32 playerCount = 0;
+    uint8 mapLevel = 0;
+
+};
+
+// The map values correspond with the .AutoBalance.XX.Name entries in the configuration file.
+static std::map<int, int> forcedCreatureIds;
+static int8 PlayerCountDifficultyOffset, LevelScaling, higherOffset, lowerOffset;
+static bool enabled, LevelEndGameBoost, DungeonsOnly, PlayerChangeNotify, LevelUseDb, DungeonScaleDownXP;
+static float globalRate, healthMultiplier, manaMultiplier, armorMultiplier, damageMultiplier, MinHPModifier, MinManaModifier, MinDamageModifier,
+InflectionPoint, InflectionPointRaid, InflectionPointRaid10M, InflectionPointRaid25M, InflectionPointRaid30M, InflectionPointHeroic, InflectionPointRaidHeroic,
+InflectionPointRaid10MHeroic, InflectionPointRaid25MHeroic, InflectionPointRaid30MHeroic, BossInflectionMult;
+
+int GetValidDebugLevel() {
+    int debugLevel = sConfigMgr->GetIntDefault("AutoBalance.DebugLevel", 2);
+    if ((debugLevel < 0) || (debugLevel > 3))
+    {
+        return 1;
+
+    }
+    return debugLevel;
+
+}
+
+// Used for reading the string from the configuration file to for those creatures who need to be scaled for XX number of players.
+void LoadForcedCreatureIdsFromString(std::string creatureIds, int forcedPlayerCount) {
+    std::string delimitedValue;
+    std::stringstream creatureIdsStream;
+
+    creatureIdsStream.str(creatureIds);
+    // Process each Creature ID in the string, delimited by the comma - ","
+    while (std::getline(creatureIdsStream, delimitedValue, ','))
+    {
+        int creatureId = atoi(delimitedValue.c_str());
+        if (creatureId >= 0)
+        {
+            forcedCreatureIds[creatureId] = forcedPlayerCount;
+
+        }
+
+    }
+}
+
+int GetForcedNumPlayers(int creatureId) {
+    // Don't want the forcedCreatureIds map to blowup to a massive empty array
+    if (forcedCreatureIds.find(creatureId) == forcedCreatureIds.end())
+    {
+        return -1;
+
+    }
+    return forcedCreatureIds[creatureId];
+}
+
+void getAreaLevel(Map* map, uint8 areaid, uint8& min, uint8& max) {
+    LFGDungeonEntry const* dungeon = DBCManager::GetLFGDungeon(map->GetId(), map->GetDifficulty());
+
+    if (dungeon && (map->IsDungeon() || map->IsRaid()))
+    {
+        min = dungeon->MinLevel;
+        max = dungeon->Target_level ? dungeon->Target_level : dungeon->Maxlevel;
+
+    }
+
+    if (!min && !max)
+    {
+        AreaTableEntry const* areaEntry = sAreaTableStore.LookupEntry(areaid);
+        if (areaEntry && areaEntry->ExplorationLevel > 0)
+        {
+            min = areaEntry->ExplorationLevel;
+            max = areaEntry->ExplorationLevel;
+
+        }
+
+    }
+}
+
+class AutoBalance_WorldScript : public WorldScript
+{
+public:
+    AutoBalance_WorldScript() : WorldScript("AutoBalance_WorldScript") {}
+
+    void OnConfigLoad(bool /*reload*/) override
+    {
+        SetInitialWorldSettings();
+    }
+
+    void OnStartup() override { }
+
+    void SetInitialWorldSettings() override
+    {
+        forcedCreatureIds.clear();
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID40", ""), 40);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID25", ""), 25);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID10", ""), 10);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID5", ""), 5);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID2", ""), 2);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.DisabledID", ""), 0);
+
+        enabled = sConfigMgr->GetBoolDefault("AutoBalance.enable", 1);
+        LevelEndGameBoost = sConfigMgr->GetBoolDefault("AutoBalance.LevelEndGameBoost", 1);
+        DungeonsOnly = sConfigMgr->GetBoolDefault("AutoBalance.DungeonsOnly", 1);
+        PlayerChangeNotify = sConfigMgr->GetBoolDefault("AutoBalance.PlayerChangeNotify", 1);
+        LevelUseDb = sConfigMgr->GetBoolDefault("AutoBalance.levelUseDbValuesWhenExists", 1);
+        DungeonScaleDownXP = sConfigMgr->GetBoolDefault("AutoBalance.DungeonScaleDownXP", 0);
+
+        LevelScaling = sConfigMgr->GetIntDefault("AutoBalance.levelScaling", 1);
+        PlayerCountDifficultyOffset = sConfigMgr->GetIntDefault("AutoBalance.playerCountDifficultyOffset", 0);
+        higherOffset = sConfigMgr->GetIntDefault("AutoBalance.levelHigherOffset", 3);
+        lowerOffset = sConfigMgr->GetIntDefault("AutoBalance.levelLowerOffset", 0);
+
+        InflectionPoint = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPoint", 0.5f);
+        InflectionPointRaid = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid", InflectionPoint);
+        InflectionPointRaid30M = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid30M", InflectionPointRaid);
+        InflectionPointRaid25M = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid25M", InflectionPointRaid);
+        InflectionPointRaid10M = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid10M", InflectionPointRaid);
+        InflectionPointHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointHeroic", InflectionPoint);
+        InflectionPointRaidHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaidHeroic", InflectionPointRaid);
+        InflectionPointRaid30MHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid30MHeroic", InflectionPointRaid30M);
+        InflectionPointRaid25MHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid25MHeroic", InflectionPointRaid25M);
+        InflectionPointRaid10MHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid10MHeroic", InflectionPointRaid10M);
+        BossInflectionMult = sConfigMgr->GetFloatDefault("AutoBalance.BossInflectionMult", 1.0f);
+        globalRate = sConfigMgr->GetFloatDefault("AutoBalance.rate.global", 1.0f);
+        healthMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.health", 1.0f);
+        manaMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.mana", 1.0f);
+        armorMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.armor", 1.0f);
+        damageMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.damage", 1.0f);
+        MinHPModifier = sConfigMgr->GetFloatDefault("AutoBalance.MinHPModifier", 0.1f);
+        MinManaModifier = sConfigMgr->GetFloatDefault("AutoBalance.MinManaModifier", 0.1f);
+        MinDamageModifier = sConfigMgr->GetFloatDefault("AutoBalance.MinDamageModifier", 0.1f);
+    }
+};
+
+class AutoBalance_PlayerScript : public PlayerScript
+{
+public:
+    AutoBalance_PlayerScript() : PlayerScript("AutoBalance_PlayerScript") { }
+
+    void OnLogin(Player* Player, bool /*firstLogin*/) override
+    {
+        if (sConfigMgr->GetBoolDefault("AutoBalanceAnnounce.enable", true))
+        {
+            ChatHandler(Player->GetSession()).SendSysMessage("This server is running the |cff4CFF00SPP Cata AutoBalance |rmodule.");
+        }
+
+    }
+
+    virtual void OnLevelChanged(Player* player, uint8 /*oldlevel*/) override
+    {
+        if (!enabled || !player)
+        {
+            return;
+        }
+
+        if (LevelScaling == 0)
+        {
+            return;
+
+        }
+
+        AutoBalanceMapInfo* mapABInfo = player->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        if (mapABInfo->mapLevel < player->getLevel())
+        {
+            mapABInfo->mapLevel = player->getLevel();
+        }
+
+    }
+
+    void OnGiveXP(Player* player, uint32& amount, Unit* victim) override
+    {
+        if (victim && DungeonScaleDownXP)
+        {
+            Map* map = player->GetMap();
+
+            if (map->IsDungeon())
+            {
+                // Ensure that the players always get the same XP, even when entering the dungeon alone
+                uint32 maxPlayerCount = ((InstanceMap*)sMapMgr->FindMap(map->GetId(), map->GetInstanceId()))->GetMaxPlayers();
+                uint32 currentPlayerCount = map->GetPlayersCountExceptGMs();
+                amount *= (float)currentPlayerCount / maxPlayerCount;
+            }
+        }
+    }
+};
+
+class AutoBalance_UnitScript : public UnitScript {
+public:
+    AutoBalance_UnitScript() : UnitScript("AutoBalance_UnitScript") {
+
+    }
+
+    //    uint32 DealDamage(Unit *AttackerUnit, Unit *playerVictim, uint32 damage, DamageEffectType /*damagetype*/) {
+    //        return _Modifer_DealDamage(playerVictim, AttackerUnit, damage);
+    //    }
+
+    void ModifyPeriodicDamageAurasTick(Unit* target, Unit* attacker, uint32& damage) override
+    {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    void ModifySpellDamageTaken(Unit* target, Unit* attacker, int32& damage) override
+    {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    void ModifyMeleeDamage(Unit* target, Unit* attacker, uint32& damage) override
+    {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    void ModifyHealRecieved(Unit* target, Unit* attacker, uint32& damage) override
+    {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    uint32 _Modifer_DealDamage(Unit* target, Unit* attacker, uint32 damage)
+    {
+        if (!enabled)
+        {
+            return damage;
+        }
+
+        if (!attacker || attacker->GetTypeId() == TYPEID_PLAYER || !attacker->IsInWorld())
+        {
+            return damage;
+        }
+
+        float damageMultiplier = attacker->CustomData.GetDefault<AutoBalanceCreatureInfo>("AutoBalanceCreatureInfo")->DamageMultiplier;
+        if (damageMultiplier == 1)
+        {
+            return damage;
+
+        }
+
+        if (!(!DungeonsOnly || (target->GetMap()->IsDungeon() && attacker->GetMap()->IsDungeon()) || (attacker->GetMap()->IsBattleground() && target->GetMap()->IsBattleground())))
+        {
+            return damage;
+        }
+
+        if ((attacker->IsHunterPet() || attacker->IsPet() || attacker->IsSummon()) && attacker->IsControlledByPlayer())
+        {
+            return damage;
+        }
+
+        return damage * damageMultiplier;
+    }
+};
+
+class AutoBalance_AllMapScript : public AllMapScript
+{
+public:
+    AutoBalance_AllMapScript() : AllMapScript("AutoBalance_AllMapScript") { }
+
+    void OnPlayerEnterAll(Map* map, Player* player)
+    {
+        if (!enabled)
+        {
+            return;
+        }
+
+        if (player->IsGameMaster())
+        {
+            return;
+
+        }
+
+        AutoBalanceMapInfo* mapABInfo = map->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        // always check level, even if not conf enabled
+        // because we can enable at runtime and we need this information
+        if (player)
+        {
+            if (player->getLevel() > mapABInfo->mapLevel)
+            {
+                mapABInfo->mapLevel = player->getLevel();
+
+            }
+
+        }
+        else {
+            Map::PlayerList const& playerList = map->GetPlayers();
+            if (!playerList.isEmpty()) {
+                for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration)
+                {
+                    if (Player* playerHandle = playerIteration->GetSource()) {
+                        if (!playerHandle->IsGameMaster() && playerHandle->getLevel() > mapABInfo->mapLevel)
+                        {
+                            mapABInfo->mapLevel = playerHandle->getLevel();
+
+                        }
+
+                    }
+                }
+            }
+        }
+
+        mapABInfo->playerCount++; //(maybe we've to found a safe solution to avoid player recount each time)
+        //mapABInfo->playerCount = map->GetPlayersCountExceptGMs();
+
+        if (PlayerChangeNotify)
+        {
+            if (map->GetEntry()->IsDungeon() && player)
+            {
+                Map::PlayerList const& playerList = map->GetPlayers();
+                if (!playerList.isEmpty())
+                {
+                    for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration)
+                    {
+                        if (Player* playerHandle = playerIteration->GetSource())
+                        {
+                            ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                            chatHandle.PSendSysMessage("|cffFF0000 [AutoBalance]|r|cffFF8000 %s entered the Instance %s. Auto setting player count to %u (Player Difficulty Offset = %u) |r",
+                                player->GetName().c_str(), map->GetMapName(), mapABInfo->playerCount + PlayerCountDifficultyOffset, PlayerCountDifficultyOffset);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    void OnPlayerLeaveAll(Map* map, Player* player)
+    {
+        if (!enabled)
+        {
+            return;
+        }
+
+        if (player->IsGameMaster())
+        {
+            return;
+        }
+
+        AutoBalanceMapInfo* mapABInfo = map->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        // (maybe we've to found a safe solution to avoid player recount each time)
+        mapABInfo->playerCount--;
+        // mapABInfo->playerCount = map->GetPlayersCountExceptGMs();
+
+        // always check level, even if not conf enabled
+        // because we can enable at runtime and we need this information
+        if (!mapABInfo->playerCount)
+        {
+            mapABInfo->mapLevel = 0;
+            return;
+        }
+
+        if (PlayerChangeNotify)
+        {
+            if (map->GetEntry()->IsDungeon() && player)
+            {
+                Map::PlayerList const& playerList = map->GetPlayers();
+                if (!playerList.isEmpty())
+                {
+                    for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration)
+                    {
+                        if (Player* playerHandle = playerIteration->GetSource())
+                        {
+                            ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                            chatHandle.PSendSysMessage("|cffFF0000 [-AutoBalance]|r|cffFF8000 %s left the Instance %s. Auto setting player count to %u (Player Difficulty Offset = %u) |r",
+                                player->GetName().c_str(), map->GetMapName(), mapABInfo->playerCount, PlayerCountDifficultyOffset);
+                        }
+                    }
+                }
+            }
+        }
+    }
+};
+
+class AutoBalance_AllCreatureScript : public AllCreatureScript {
+public:
+    AutoBalance_AllCreatureScript() : AllCreatureScript("AutoBalance_AllCreatureScript") { }
+
+    void Creature_SelectLevel(const CreatureTemplate* /*creatureTemplate*/, Creature* creature) override
+    {
+        if (!enabled)
+        {
+            return;
+        }
+        ModifyCreatureAttributes(creature, true);
+
+    }
+
+    void OnAllCreatureUpdate(Creature* creature, uint32 /*diff*/) override
+    {
+        if (!enabled)
+        {
+            return;
+
+        }
+        ModifyCreatureAttributes(creature);
+
+    }
+
+    bool checkLevelOffset(uint8 selectedLevel, uint8 targetLevel) {
+        return selectedLevel && ((targetLevel >= selectedLevel && targetLevel <= (selectedLevel + higherOffset)) || (targetLevel <= selectedLevel && targetLevel >= (selectedLevel - lowerOffset)));
+
+    }
+
+    void ModifyCreatureAttributes(Creature* creature, bool resetSelLevel = false)
+    {
+        if (!creature || !creature->GetMap())
+        {
+            return;
+        }
+
+        if (!creature->GetMap()->IsDungeon() && !creature->GetMap()->IsBattleground() && DungeonsOnly)
+        {
+            return;
+        }
+
+        if (((creature->IsHunterPet() || creature->IsPet() || creature->IsSummon()) && creature->IsControlledByPlayer()))
+        {
+            return;
+        }
+
+        AutoBalanceMapInfo* mapABInfo = creature->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        if (!mapABInfo->mapLevel)
+        {
+            return;
+        }
+
+        CreatureTemplate const* creatureTemplate = creature->GetCreatureTemplate();
+        InstanceMap* instanceMap = ((InstanceMap*)sMapMgr->FindMap(creature->GetMapId(), creature->GetInstanceId()));
+        uint32 maxNumberOfPlayers = instanceMap->GetMaxPlayers();
+        int forcedNumPlayers = GetForcedNumPlayers(creatureTemplate->Entry);
+
+        if (forcedNumPlayers > 0)
+        {
+            // Force maxNumberOfPlayers to be changed to match the Configuration entries ForcedID2, ForcedID5, ForcedID10, ForcedID20, ForcedID25, ForcedID40
+            maxNumberOfPlayers = forcedNumPlayers;
+        }
+        else if (forcedNumPlayers == 0)
+        {
+            // forcedNumPlayers 0 means that the creature is contained in DisabledID -> no scaling
+            return;
+        }
+
+        AutoBalanceCreatureInfo* creatureABInfo = creature->CustomData.GetDefault<AutoBalanceCreatureInfo>("AutoBalanceCreatureInfo");
+        // force resetting selected level.
+        // this is also a "workaround" to fix bug of not recalculated
+        // attributes when UpdateEntry has been used.
+        // TODO: It's better and faster to implement a core hook
+        // in that position and force a recalculation then
+        if ((creatureABInfo->entry != 0 && creatureABInfo->entry != creature->GetEntry()) || resetSelLevel)
+        {
+            // force a recalculation
+            creatureABInfo->selectedLevel = 0;
+        }
+
+        if (!creature->IsAlive())
+        {
+            return;
+        }
+
+        uint32 curCount = mapABInfo->playerCount + PlayerCountDifficultyOffset;
+        uint8 bonusLevel = creatureTemplate->rank == CREATURE_ELITE_WORLDBOSS ? 3 : 0;
+
+        // already scaled
+        if (creatureABInfo->selectedLevel > 0)
+        {
+            if (LevelScaling)
+            {
+                if (checkLevelOffset(mapABInfo->mapLevel + bonusLevel, creature->getLevel()) &&
+                    checkLevelOffset(creatureABInfo->selectedLevel, creature->getLevel()) &&
+                    creatureABInfo->instancePlayerCount == curCount)
+                {
+                    return;
+                }
+            }
+            else if (creatureABInfo->instancePlayerCount == curCount)
+            {
+                return;
+            }
+        }
+
+        creatureABInfo->instancePlayerCount = curCount;
+        // no players in map, do not modify attributes
+        if (!creatureABInfo->instancePlayerCount)
+        {
+            return;
+        }
+
+        uint8 originalLevel = creatureTemplate->maxlevel;
+        uint8 level = mapABInfo->mapLevel;
+        uint8 areaMinLvl, areaMaxLvl;
+        getAreaLevel(creature->GetMap(), creature->GetAreaId(), areaMinLvl, areaMaxLvl);
+
+        // avoid level changing for critters and special creatures (spell summons etc.) in instances
+        bool skipLevel = false;
+        if (originalLevel <= 1 && areaMinLvl >= 5)
+        {
+            skipLevel = true;
+        }
+
+        if (LevelScaling && creature->GetMap()->IsDungeon() && !skipLevel && !checkLevelOffset(level, originalLevel))
+        {
+            // change level only whithin the offsets and when in dungeon/raid
+            if (level != creatureABInfo->selectedLevel || creatureABInfo->selectedLevel != creature->getLevel())
+            {
+                // keep bosses +3 level
+                creatureABInfo->selectedLevel = level + bonusLevel;
+                creature->SetLevel(creatureABInfo->selectedLevel);
+            }
+        }
+        else
+        {
+            creatureABInfo->selectedLevel = creature->getLevel();
+        }
+
+        creatureABInfo->entry = creature->GetEntry();
+        bool useDefStats = false;
+        if (LevelUseDb && creature->getLevel() >= creatureTemplate->minlevel && creature->getLevel() <= creatureTemplate->maxlevel)
+        {
+            useDefStats = true;
+        }
+
+        CreatureBaseStats const* origCreatureStats = sObjectMgr->GetCreatureBaseStats(originalLevel, creatureTemplate->unit_class);
+        CreatureBaseStats const* creatureStats = sObjectMgr->GetCreatureBaseStats(creatureABInfo->selectedLevel, creatureTemplate->unit_class);
+
+        uint32 baseHealth = origCreatureStats->GenerateHealth(creatureTemplate);
+        uint32 baseMana = origCreatureStats->GenerateMana(creatureTemplate);
+        uint32 scaledHealth = 0;
+        uint32 scaledMana = 0;
+
+        // Note: InflectionPoint handle the number of players required to get 50% health.
+        //       you'd adjust this to raise or lower the hp modifier for per additional player in a non-whole group.
+        //
+        //       diff modify the rate of percentage increase between
+        //       number of players. Generally the closer to the value of 1 you have this
+        //       the less gradual the rate will be. For example in a 5 man it would take 3
+        //       total players to face a mob at full health.
+        //
+        //       The +1 and /2 values raise the TanH function to a positive range and make
+        //       sure the modifier never goes above the value or 1.0 or below 0.
+        //
+        float defaultMultiplier = 1.0f;
+        if (creatureABInfo->instancePlayerCount < maxNumberOfPlayers)
+        {
+            float inflectionValue = (float)maxNumberOfPlayers;
+
+            if (instanceMap->IsHeroic())
+            {
+                if (instanceMap->IsRaid())
+                {
+                    switch (instanceMap->GetMaxPlayers())
+                    {
+                    case 10:
+                        inflectionValue *= InflectionPointRaid10MHeroic;
+                        break;
+                    case 25:
+                        inflectionValue *= InflectionPointRaid25MHeroic;
+                        break;
+                    case 30:
+                        inflectionValue *= InflectionPointRaid30MHeroic;
+                        break;
+                    default:
+                        inflectionValue *= InflectionPointRaidHeroic;
+                    }
+                }
+                else
+                {
+                    inflectionValue *= InflectionPointHeroic;
+                }
+            }
+            else
+            {
+                if (instanceMap->IsRaid())
+                {
+                    switch (instanceMap->GetMaxPlayers())
+                    {
+                    case 10:
+                        inflectionValue *= InflectionPointRaid10M;
+                        break;
+                    case 25:
+                        inflectionValue *= InflectionPointRaid25M;
+                        break;
+                    case 30:
+                        inflectionValue *= InflectionPointRaid30M;
+                        break;
+                    default:
+                        inflectionValue *= InflectionPointRaid;
+
+                    }
+                }
+                else
+                {
+                    inflectionValue *= InflectionPoint;
+                }
+            }
+            if (creature->IsDungeonBoss())
+            {
+                inflectionValue *= BossInflectionMult;
+            }
+
+            float diff = ((float)maxNumberOfPlayers / 5) * 1.5f;
+            defaultMultiplier = (tanh(((float)creatureABInfo->instancePlayerCount - inflectionValue) / diff) + 1.0f) / 2.0f;
+
+        }
+
+        creatureABInfo->HealthMultiplier = healthMultiplier * defaultMultiplier * globalRate;
+
+        if (creatureABInfo->HealthMultiplier <= MinHPModifier)
+        {
+            creatureABInfo->HealthMultiplier = MinHPModifier;
+        }
+
+        float hpStatsRate = 1.0f;
+        if (!useDefStats && LevelScaling && !skipLevel)
+        {
+            float newBaseHealth = 0;
+            if (level <= 60)
+            {
+                newBaseHealth = creatureStats->BaseHealth[0];
+            }
+            else if (level <= 70)
+            {
+                newBaseHealth = creatureStats->BaseHealth[1];
+            }
+            else
+            {
+                newBaseHealth = creatureStats->BaseHealth[2];
+                // special increasing for end-game contents
+                if (LevelEndGameBoost)
+                {
+                    newBaseHealth *= creatureABInfo->selectedLevel >= 75 && originalLevel < 75 ? float(creatureABInfo->selectedLevel - 70) * 0.3f : 1;
+                }
+            }
+
+            float newHealth = newBaseHealth * creatureTemplate->ModHealth;
+            // allows health to be different with creatures that originally
+            // differentiate their health by different level instead of multiplier field.
+            // expecially in dungeons. The health reduction decrease if original level is similar to the area max level
+            if (originalLevel >= areaMinLvl && originalLevel < areaMaxLvl)
+            {
+                // never more than 30%
+                float reduction = newHealth / float(areaMaxLvl - areaMinLvl) * (float(areaMaxLvl - originalLevel) * 0.3f);
+                if (reduction > 0 && reduction < newHealth)
+                {
+                    newHealth -= reduction;
+                }
+            }
+            hpStatsRate = newHealth / float(baseHealth);
+        }
+
+        creatureABInfo->HealthMultiplier *= hpStatsRate;
+        scaledHealth = round(((float)baseHealth * creatureABInfo->HealthMultiplier) + 1.0f);
+
+        // Getting the list of Classes in this group
+        // This will be used later on to determine what additional scaling will be required based on the ratio of tank/dps/healer
+        // Update playerClassList with the list of all the participating Classes
+        // GetPlayerClassList(creature, playerClassList);
+
+        float manaStatsRate = 1.0f;
+        if (!useDefStats && LevelScaling && !skipLevel)
+        {
+            float newMana = creatureStats->GenerateMana(creatureTemplate);
+            manaStatsRate = newMana / float(baseMana);
+        }
+
+        creatureABInfo->ManaMultiplier = manaStatsRate * manaMultiplier * defaultMultiplier * globalRate;
+        if (creatureABInfo->ManaMultiplier <= MinManaModifier)
+        {
+            creatureABInfo->ManaMultiplier = MinManaModifier;
+        }
+
+        scaledMana = round(baseMana * creatureABInfo->ManaMultiplier);
+        float damageMul = defaultMultiplier * globalRate * damageMultiplier;
+        // Can not be less then Min_D_Mod
+        if (damageMul <= MinDamageModifier)
+        {
+            damageMul = MinDamageModifier;
+        }
+
+        if (!useDefStats && LevelScaling && !skipLevel)
+        {
+            float origDmgBase = origCreatureStats->GenerateBaseDamage(creatureTemplate);
+            float newDmgBase = 0;
+            if (level <= 60)
+            {
+                newDmgBase = creatureStats->BaseDamage[0];
+            }
+            else if (level <= 70)
+            {
+                newDmgBase = creatureStats->BaseDamage[1];
+            }
+            else
+            {
+                newDmgBase = creatureStats->BaseDamage[2];
+                // special increasing for end-game contents
+                if (LevelEndGameBoost && !creature->GetMap()->IsRaid())
+                    newDmgBase *= creatureABInfo->selectedLevel >= 75 && originalLevel < 75 ? float(creatureABInfo->selectedLevel - 70) * 0.3f : 1;
+            }
+
+            damageMul *= newDmgBase / origDmgBase;
+
+        }
+
+        creatureABInfo->ArmorMultiplier = defaultMultiplier * globalRate * armorMultiplier;
+        uint32 newBaseArmor = round(creatureABInfo->ArmorMultiplier *
+            ((useDefStats || !LevelScaling || skipLevel) ? origCreatureStats->GenerateArmor(creatureTemplate)
+                : creatureStats->GenerateArmor(creatureTemplate)));
+        uint32 prevMaxHealth = creature->GetMaxHealth();
+        uint32 prevMaxPower = creature->GetMaxPower(POWER_MANA);
+        uint32 prevHealth = creature->GetHealth();
+        uint32 prevPower = creature->GetPower(POWER_MANA);
+        Powers pType = creature->GetPowerType();
+
+        creature->SetArmor(newBaseArmor);
+        creature->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, (float)newBaseArmor);
+        creature->SetCreateHealth(scaledHealth);
+        creature->SetMaxHealth(scaledHealth);
+        creature->ResetPlayerDamageReq();
+        creature->SetCreateMana(scaledMana);
+        creature->SetMaxPower(POWER_MANA, scaledMana);
+        creature->SetModifierValue(UNIT_MOD_ENERGY, BASE_VALUE, (float)100.0f);
+        creature->SetModifierValue(UNIT_MOD_RAGE, BASE_VALUE, (float)100.0f);
+        creature->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, (float)scaledHealth);
+        creature->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, (float)scaledMana);
+        creatureABInfo->DamageMultiplier = damageMul;
+
+        uint32 scaledCurHealth = prevHealth && prevMaxHealth ? float(scaledHealth) / float(prevMaxHealth) * float(prevHealth) : 0;
+        uint32 scaledCurPower = prevPower && prevMaxPower ? float(scaledMana) / float(prevMaxPower) * float(prevPower) : 0;
+
+        creature->SetHealth(scaledCurHealth);
+        if (pType == POWER_MANA)
+        {
+            creature->SetPower(POWER_MANA, scaledCurPower);
+        }
+        else
+        {
+            // fix creatures with different power types
+            creature->SetPowerType(pType);
+        }
+        creature->UpdateAllStats();
+    }
+};
+
+using namespace Trinity::ChatCommands;
+
+class AutoBalance_CommandScript : public CommandScript
+{
+public:
+    AutoBalance_CommandScript() : CommandScript("AutoBalance_CommandScript") { }
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+        static std::vector<ChatCommand> ABCommandTable =
+        {
+            { "setoffset",        SEC_GAMEMASTER,                        true, &HandleABSetOffsetCommand,                 "Sets the global Player Difficulty Offset for instances. Example: (You + offset(1) = 2 player difficulty)." },
+            { "getoffset",        SEC_GAMEMASTER,                        true, &HandleABGetOffsetCommand,                 "Shows current global player offset value" },
+            { "checkmap",         SEC_GAMEMASTER,                        true, &HandleABCheckMapCommand,                  "Run a check for current map/instance, it can help in case you're testing autobalance with GM." },
+            { "mapstat",          SEC_GAMEMASTER,                        true, &HandleABMapStatsCommand,                  "Shows current autobalance information for this map-" },
+            { "crstat",           SEC_GAMEMASTER,                        true, &HandleABCreatureStatsCommand,             "Shows current autobalance information for selected creature." },
+        };
+
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "vas", SEC_GAMEMASTER,                            false, NULL,                      "", ABCommandTable },
+        };
+        return commandTable;
+
+    }
+
+    static bool HandleABSetOffsetCommand(ChatHandler* handler, uint32 offseti)
+    {
+        handler->PSendSysMessage("Changing Player Difficulty Offset to %i.", offseti);
+        PlayerCountDifficultyOffset = offseti;
+        return true;
+    }
+
+    static bool HandleABGetOffsetCommand(ChatHandler* handler)
+    {
+        handler->PSendSysMessage("Current Player Difficulty Offset = %i", PlayerCountDifficultyOffset);
+        return true;
+    }
+
+    static bool HandleABCheckMapCommand(ChatHandler* handler)
+    {
+        Player* pl = handler->getSelectedPlayer();
+
+        if (!pl)
+        {
+            handler->SendSysMessage(LANG_SELECT_PLAYER_OR_PET);
+            handler->SetSentErrorMessage(true);
+            return false;
+
+        }
+
+        AutoBalanceMapInfo* mapABInfo = pl->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        mapABInfo->playerCount = pl->GetMap()->GetPlayersCountExceptGMs();
+
+        Map::PlayerList const& playerList = pl->GetMap()->GetPlayers();
+        uint8 level = 0;
+        if (!playerList.isEmpty())
+        {
+            for (Map::PlayerList::const_iterator playerIteration = playerList.begin();
+                playerIteration != playerList.end(); ++playerIteration)
+            {
+                if (Player* playerHandle = playerIteration->GetSource())
+                {
+                    if (playerHandle->getLevel() > level)
+                    {
+                        mapABInfo->mapLevel = level = playerHandle->getLevel();
+
+                    }
+
+                }
+
+            }
+
+        }
+        HandleABMapStatsCommand(handler);
+        return true;
+
+    }
+
+    static bool HandleABMapStatsCommand(ChatHandler* handler)
+    {
+        Player* pl = handler->getSelectedPlayer();
+        if (!pl)
+        {
+            handler->SendSysMessage(LANG_SELECT_PLAYER_OR_PET);
+            handler->SetSentErrorMessage(true);
+            return false;
+
+        }
+
+        AutoBalanceMapInfo* mapABInfo = pl->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        handler->PSendSysMessage("Players on map: %u", mapABInfo->playerCount);
+        handler->PSendSysMessage("Max level of players in this map: %u", mapABInfo->mapLevel);
+        return true;
+
+    }
+
+    static bool HandleABCreatureStatsCommand(ChatHandler* handler)
+    {
+        Creature* target = handler->getSelectedCreature();
+
+        if (!target)
+        {
+            handler->SendSysMessage(LANG_SELECT_CREATURE);
+            handler->SetSentErrorMessage(true);
+            return false;
+
+        }
+
+        AutoBalanceCreatureInfo* creatureABInfo = target->CustomData.GetDefault<AutoBalanceCreatureInfo>("AutoBalanceCreatureInfo");
+        handler->PSendSysMessage("Instance player Count: %u", creatureABInfo->instancePlayerCount);
+        handler->PSendSysMessage("Selected level: %u", creatureABInfo->selectedLevel);
+        handler->PSendSysMessage("Damage multiplier: %.6f", creatureABInfo->DamageMultiplier);
+        handler->PSendSysMessage("Health multiplier: %.6f", creatureABInfo->HealthMultiplier);
+        handler->PSendSysMessage("Mana multiplier: %.6f", creatureABInfo->ManaMultiplier);
+        handler->PSendSysMessage("Armor multiplier: %.6f", creatureABInfo->ArmorMultiplier);
+        return true;
+    }
+};
+
+void AddSC_AutoBalance()
+{
+    new AutoBalance_WorldScript;
+    new AutoBalance_PlayerScript;
+    new AutoBalance_UnitScript;
+    new AutoBalance_AllCreatureScript;
+    new AutoBalance_AllMapScript;
+    new AutoBalance_CommandScript;
+}

-------------- src/server/scripts/Custom/custom_script_loader.cpp --------------
index 96571f2786..d786156039 100644
@@ -24,6 +24,7 @@ void AddSolocraftScripts();
 void AddSC_skip_StarterArea();
 void AddSC_start_equipment();
 void AddSC_XpWeekend();
+void AddSC_AutoBalance();
 
 void AddCustomScripts()
 {
@@ -31,4 +32,5 @@ void AddCustomScripts()
 	AddSC_skip_StarterArea();
     AddSC_start_equipment();
     AddSC_XpWeekend();
+    AddSC_AutoBalance();
 }

----------------- src/server/worldserver/worldserver.conf.dist -----------------
index f28bbac683..85015df697 100644
@@ -4830,3 +4830,198 @@ DoubleXP.Enable = 1
 
 #
 ###################################################################################################
+
+###################################################################################################
+#
+# AUTOBALANCE ANNOUNCE
+#
+#     AutoBalanceAnnounce.enable
+#        Announce the module on login
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalanceAnnounce.enable = 0
+
+#
+# AUTOBALANCE OPTIONS
+#
+#     AutoBalance.enable
+#        Enable/Disable the autobalance system
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.enable = 0
+
+#     AutoBalance.InflectionPoint series
+#        Adjust value of Hyperbolic Tangent function where
+#        the curve of scaling must change. A lower value means higher difficulty.
+#        InflectionPoint & InflectionPointHeroic are the fallback values for 5-man dungeons
+#        InflectionPointRaid10M & InflectionPointRaid10MHeroic are the fallback values for 10 man raids
+#        InflectionPointRaid25M & InflectionPointRaid25MHeroic are the fallback values for 25 man raids
+#        InflectionPointRaid30M & InflectionPointRaid30MHeroic are the fallback values for 30 man raids
+#        InflectionPointRaid & InflectionPointRaidHeroic are the fallback values for other raids (40-man, 20-man, 15-man, or custom size)
+#        The inflection points fallback to the most specific number
+#
+#        Example: with 0.5 in InflectionPointRaid, a creature of raid (40) will have half of its life with 20 players in
+#                 with 0.8, the same creature will have half of its life with 12 players in
+#
+#        Default:     0.5
+
+AutoBalance.InflectionPoint = 0.5
+AutoBalance.InflectionPointHeroic = 0.5
+
+AutoBalance.InflectionPointRaid10M = 0.5
+AutoBalance.InflectionPointRaid10MHeroic = 0.5
+
+AutoBalance.InflectionPointRaid25M = 0.5
+AutoBalance.InflectionPointRaid25MHeroic = 0.5
+
+AutoBalance.InflectionPointRaid30M = 0.5
+AutoBalance.InflectionPointRaid30MHeroic = 0.5
+
+AutoBalance.InflectionPointRaid = 0.5
+AutoBalance.InflectionPointRaidHeroic = 0.5
+
+#
+#     AutoBalance.BossInflectionMult
+#        Multiplies the inflection point of bosses, only applies to creatures considered dungeon bosses (from dungeons or raids).
+#        Example: If AutoBalance.BossInflectionMult = 0.4 and AutoBalance.InflectionPoint=0.5, the bosses inflection point will be 0.4*0.9 = 0.36 in a normal dungeon.
+#        Default:     1.0
+
+AutoBalance.BossInflectionMult = 1.0
+
+#
+#     AutoBalance.levelScaling
+#        Check the max level of players in map and scale creature based on it.
+#        This triggers depending on the two options below AutoBalance.levelHigherOffset and AutoBalance.levelLowerOffset
+#        0 = Disabled
+#        1 = Enabled (only in dungeons/raids)
+#        Default:     1
+
+AutoBalance.levelScaling = 0
+
+#
+#     AutoBalance.levelHigherOffset
+#     AutoBalance.levelLowerOffset
+#        Level Offsets between creatures will not be scaled by level.
+#        You can even use it to disable scaling from lower to higher levelScaling
+#        setting levelLowerOffset to 80 (max wotlk level) for example.
+#        default: 3 (higher), 0 (lower)
+
+AutoBalance.levelHigherOffset = 3
+AutoBalance.levelLowerOffset  = 0
+
+#
+#     AutoBalance.levelUseDbValuesWhenExists
+#        When enabled with levelScaling, the creature will use its default database values
+#        instead of level scaling formula when player/party level has correspondance with
+#        creature_template minlevel/maxlevel.
+#
+#        Default:     0 (1 = ON, 0 = OFF)
+
+AutoBalance.levelUseDbValuesWhenExists = 0
+
+#
+#     AutoBalance.LevelEndGameBoost
+#        End game creatures have an exponential (not linear) regression
+#        that is not correctly handled by db values. Keep this enabled
+#        to have stats as near possible to the official ones.
+#
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.LevelEndGameBoost = 1
+
+#
+     AutoBalance.DungeonScaleDownXP
+#        Decrease individual player's amount of XP gained during a dungeon to match the
+#        amount of XP gained during a full group run. Example: In a 5-man group, you
+#        earn 1/5 of the total XP per kill, but if you solo the dungeon with
+#        AutoBalance.DungeonScaleDownXP = 0, you will earn 5/5 of the total XP.
+#        With the option enabled, you will earn 1/5.
+#        Default:     0 (1 = ON, 0 = OFF)
+
+AutoBalance.DungeonScaleDownXP = 0
+
+#
+#     AutoBalance.DungeonsOnly
+#        Only apply scaling changes to dungeons and raids
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.DungeonsOnly = 1
+
+#
+#     AutoBalance.DebugLevel
+#        0 = None
+#        1 = Errors Only
+#        2 = Errors and Basic Information
+#        3 = All  Info
+#        Default:     2
+
+AutoBalance.DebugLevel = 2
+
+#
+#     AutoBalance.PlayerChangeNotify
+#        Set Auto Notifications to all players in Instance that player count has changed.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.PlayerChangeNotify = 1
+
+#
+#     AutoBalance.MinHPModifier
+#        Minimum Modifier setting for Health Modification
+#        Default:     0.01
+
+AutoBalance.MinHPModifier = 0.01
+
+#
+#     AutoBalance.MinManaModifier
+#        Minimum Modifier setting for Mana Modification
+#        Default:     0.01
+
+AutoBalance.MinManaModifier = 0.01
+
+#
+#     AutoBalance.MinDamageModifier
+#        Minimum Modifier setting for Damage Modification
+#        Default:     0.01
+
+AutoBalance.MinDamageModifier = 0.01
+
+#
+#     AutoBalance.rate.*
+#        You can tune all rates increasing/decreasing difficulty in a linear way
+#        Note that global rate will increase all other rates. For example:
+#        global = 2.0 , damage = 1.5  -> it means that damage will be 3.0
+#        Default:     1.0
+
+AutoBalance.rate.global = 1.0
+AutoBalance.rate.health = 1.0
+AutoBalance.rate.mana   = 1.0
+AutoBalance.rate.armor  = 1.0
+AutoBalance.rate.damage = 1.0
+
+#
+#     AutoBalance.playerCountDifficultyOffset
+#        Offset of players inside an instance
+#        Default:     0
+
+AutoBalance.playerCountDifficultyOffset = 0
+
+#
+#     AutoBalance.ForcedIDXX
+#        Sets MobIDs for the group they belong to.
+#        All 5 Man Mobs should go in .AutoBalance.5.Name
+#        All 10 Man Mobs should go in .AutoBalance.10.Name etc.
+
+AutoBalance.ForcedID40 = "11583,16441,30057,13020,15589,14435,18192,14889,14888,14887,14890,15302,15818,15742,15741,15740,18338"
+AutoBalance.ForcedID25 = "22997,21966,21965,21964,21806,21215,21845,19728,12397,17711,18256,18192,"
+AutoBalance.ForcedID20 = ""
+AutoBalance.ForcedID10 = "15689,15550,16152,17521,17225,16028,29324,31099"
+AutoBalance.ForcedID5  = "8317,15203,15204,15205,15305,6109,26801,30508,26799,30495,26803,30497,27859,27249"
+AutoBalance.ForcedID2  = ""
+
+#
+#     AutoBalance.DisabledID
+#        Disable scaling on specific creatures
+#
+
+AutoBalance.DisabledID = ""
+################################################################################################### 
\ No newline at end of file

